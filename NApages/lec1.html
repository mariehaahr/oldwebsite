<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="'https://fonts.googleapis.com/css2?family=Arimo&family=Montserrat:wght@300&display=swap'" rel="stylesheet">
    <link href='https://fonts.google.com/specimen/Questrial?preview.text=Welcome%20to%20my%20webpage!&preview.text_type=custom' rel="stylesheet">
    <link href="../styles.css" rel="stylesheet">
    <title>Lecture 1 NA | mariehaahrnotes</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</head>
    <body class="full-height-grow"> <!-- for at få plads i begge sider af hjemmesiden (margin agtig)-->
        <header class="main-header"> 
            <div class="container">
                <a href="../index.html" class="brand-logo">  <!-- Laver en klasse til logo, så den kan acesses i CSS-->
                    <div class="brand-logo-name"> mariehaahrnotes</div>
                </a>
                <nav class="main-nav">
                <nav> <!-- nav element, baren i toppen som kan navigere et andet sted hen-->
                    <ul> <!-- Unordered list-->
                        <li> <a href="../na.html"> Network Analysis</a></li>
                        <li> <a href="../ml.html"> Machine Learning</a></li>

                    </ul>
                </nav>
            </header>
            </div>
                <div class="website-wrapper"> 
                    <div class="container">
                        <div class="blog-text">
                            <div class="title"> Lecture 1 - Graph basics, hypergraphs, dynamic graphs</div>
                            <div><i>Chapters 3 & 4 in "The Atlas for the Aspiring Network Scientist”</i></div>
                            <div class="subtitle"> 3 - Basic Graphs </div>
                            <div> Edge weights can be interpreted in two opposite ways, depending on what the network is representing. 
                                They can be considered the proximity between the two nodes or their distance.</div>
                            <br>
                            <div>To sum up, <i>"proximity"</i>  means that a high weight makes the nodes closer together; e.g. they interact 
                                a lot, the edge has a high capacity. <i>"“Distance”</i> means that a high weight makes the nodes 
                                further apart; e.g. it’s harder or costly to make the nodes interact. </div>
                            <br>
                            <div class="subsubtitle">Network Backboning</div>
                            <div>Since every pair of nodes have a similarity (because any two vectors can be correlated, minus extremely 
                                rare degenerate cases), every node is connected to every other node. So, when working with similarity 
                                networks, you will have to filter your connections somehow, a process we call “network back-boning” 
                                which is far less trivial that it might sound.</div>
                            <div class="subtitle">4 - Extended Graphs</div>
                            <div class="subsubtitle">Bipartite Graphs</div>
                            <div>Bipartite networks are networks in which nodes must be part of wither of two classes (\(V_1\) and \(V_2\)) and 
                                edges can only be established between nodes of unlike type. Formally we write \(G=(V_1,V_2,E)\) and that 
                            \(E\) can only contain edges like \((v_1,v_2)\), and it has to be from each class.</div>
                            <br>
                            <div><i>Examples of Bipartite Networks:</i> Connecting countries to the products they export, users to the social media 
                                items they tag, bank-firm relation ships in financial networks etc.</div>
                            <br>
                            <div><i>Multilayer networks</i> also consist of nodes and edges, but the nodes exist in separate <i>layers</i>, 
                                representing different forms of interactions, which connect to form an aspect. Aspects, or stacks of layers, 
                                can be used to represent different types of contacts, spatial locations, subsystems, or points in time. 
                                The edges between nodes in the same layer of an aspect are called <i>intralayer connections</i>, whereas edges 
                                between nodes in different layers are interlayer connections.</div>
                            <div class="subsubtitle">Multilayer Graphs</div>
                            <div><i>One-to-one: </i>Sometimes also called <i>multiplex networks</i>: \(G=(V,E,L)\).  Where \(V\) and \(E\) are 
                                sets of nodes and edges and \(L\) are sets of layers. Works like a class label, and is qualitative. \((u,v,l,w)\) if weights are added. 
                                However, in this case, we can add a “type” to each connection, making them qualitatively different: one edge type for Facebook, one for 
                                Twitter, one for LinkedIn. This strategy rests on the assumption that there is a one-to-one node mapping between the layers of the network.</div>
                            <br>
                            <div><i>Many-to-many: </i>Sometimes called "networks of networks", because each layer can be seen as a distinct network, and the interlayer couplings are 
                                relationships between different networks. \(G=(V,E,L,C)\).</div>
                            <div>Sometimes a node in one layer can map to multiple nodes – or none! – in another layer. <i>“interlayer coupling”:</i> In this scenario, the node is split
                            into the different layers to which it belongs.</div>
                            <div>The inter-layer edges run between layers, and their function is to establish that the two nodes in the different layers are really the same node:
                                they are coupled to - or dependent on - each other.</div>
                            <div class="right-image"> 
                                <img style="float: right;" src="NAimages/interlayercoupling.png" height="250px" width="630px" alt="Interlayer Coupling Img">
                                <div class="subsubtitle">Interlayer coupling</div>
                                <div>To fix the insufficient power of multiplex networks to represent true multilayer systems, we need to extend the model. 
                                    In this scenario, the node is split into the different layers to which it belongs.</div>
                                <div>(For example, your identity includes multiple personas: you are the union of the "Facebook you", the 
                                    "LinkedIn you", the "Twitter you".) </div>
                                <br> <div>We see on the image on the right, a visual representation of this model: each layer is a slice of the network. 
                                    There are two types of edges: The <i>intra-layer connections</i> – the traditional type: we’re friends on Facebook, 
                                    Linkedin, Twitter –, and the inter-layer connections. The <i>inter-layer edges</i> run between layers, and their 
                                    function is to establish that the two nodes in the different layers are really the same node: they are <i>coupled</i> 
                                    to – or <i>dependent</i> on – each other.</div>
                            </div>
                            <br>
                            <div> We can now have nodes in one layer expressing coupling with multiple nodes in other layers. In our social 
                                media case, we are now allowing you to have multiple profiles in one platform that still map on your single 
                                profile in another. For instance, you can run as many different Twitter accounts as you want, and they are still 
                                coupled with your Facebook account.</div>
                            <br><div><i>The actor:</i></div>
                            <div>In practice, the actor is a connected component when only considering inter-layer couplings as the possible edges. 
                                If my three Twitter profiles all refer to the same person, with maybe two Flickr accounts and one Facebook profile, 
                                all these identities belong to the same actor: me.</div>
                            <div class="subsubsubtitle">Signed Networks</div>
                            <div>Signed networks are not necessarily restricted to either a single positive or a single negative relationship – e.g. 
                                “I trust this person” or “I don’t trust this person”. For instance, in an online game, you can have multiple positive 
                                relationships like being friends or trading together; and multiple reasons to have a negative relationship, 
                                like fighting each other, or putting a bounty on each other's heads.</div>
                            <div class="subsubsubtitle">Positive and Negative Relationships</div>
                            <div>Positive and negative relationships have different dynamics. There is a limit to the number of people you can be friends with, 
                                but there is no limit to the number of people that can be mad at you.</div>
                            <div class="subsubtitle">Hypergraphs</div>
                            <div>A collection of hyper-edges is a hyper-graph. There are some cases in which connections bind together multiple 
                                people at the same time. For example a group project. The same relationship connects you with all of them. When er 
                                allow the same edge to connect more than two nodes we hall it a hyper-edge.
                                To make them more manageable, we can put constraints to hyper-edges. We could force them to always contain the same 
                                number of nodes. In a soccer tournament, the hyper-edge representing a team can only have eleven members: not one more 
                                nor one less, be- cause that’s the number of players in the team. In this case, we call the resulting structure a 
                                “uniform hyper-graph”, and have all sorts of interesting properties. In general, when simply talking about 
                                hyper-graphs we have no such constraint. There are two main strategies to <i>simplify hyper-graphs</i>. 
                                The first is to transform the hyper-edge into the simple edges it stands for.The second strategy is to turn the 
                                hyper-graph into a bipartite network.</div>
                            <div class="subsubtitle">Dynamic Graphs</div>
                            <div> \[G=(G_1,G_2,...,G_n) \\ G_i(V_i, E_i) \ \ i=\text{i'th time snapshot }\] 
                                Most networks can change. For example nodes are people and edges are when they interact with each other 
                                through a day. That changes through time. To deal with dynamic information when we want to create a 
                                static view of the network, you can use 4 standard techniques:</div>
                                <ol>
                                    <li><strong>Single snapshot</strong> - This is the simplest technique. You choose a moment in time and your graph is simply the collection 
                                        of nodes and edges active at that precise instant. This strategy works well when the edges in your network are “on” by default. It risks 
                                        creating an empty network when edges are ephemeral and/or there are long lulls in the connection patterns, for instance in telecommunication networks at night.</li>
                                    <li><strong>Disjoint Windows</strong> - Similar to single snapshot. Here we allow longer periods of time to accumulate information. Differently 
                                        from the previous technique, no information is discarded: when a window ends, the next one begins immediately. Works well when it’s not important to maintain continuity.</li>
                                    <li><strong>Sliding Windows</strong> - Similar to disjoint windows, with the difference that we allow the observation periods to overlap. That is, 
                                        the next window starts before the previous one ended. Works well when it is important to maintain continuity.</li>
                                    <li><strong>Cumulative Windows</strong> - Similar to sliding windows, but here we fix the beginning of each window at the beginning of the 
                                        observation period. Information can only accumulate: we never discard edge information, no matter how long ago it was firstly generated. Each window includes the information of all</li>
                                  </ol>
                            <div class="center-image">
                                <img src="NAimages/dynamic.png" alt="4 dynamic graphs" height="480px" width="780px" style="margin-left: 70px;"> 
                            </div>
                            <div class="subtitle">Four Network Types</div>
                            <div class="subsubtitle">1. Simple Networks</div>
                            <div>A simple network is a network we can fully describe analytically. You can have a simple formula that tells you 
                                everything you need to know about it. That is not possible in complex networks. The difference between a complex and a simple network is 
                                the same as the difference between a human being and a sphere. You can fully describe the shape of a sphere with a few 
                                formulas. But describing the shape of a human being is not as easy. Here we see simple networks as lattices (grids) to the right. 
                                There are other simple networks out there. Lattices can be very useful as a starting point of many advanced tasks. They are the basics of our 
                                understanding of epidemic spread in society. Other than that, there are simple networks such as the lollipop graph, the wheel graph and many more. </div>
                            <div class="subsubtitle">2. Complex Graphs</div>
                            <div>You can divide complex networks into two categories: <i>Complex networks with fundamental metadata</i> and <i>Complex networks without fundamental metadata.</i>
                                The difference between the two types is that, if the metadata are fundamental, they change the way you interpret some or all the metadata themselves.
                                For instance, some networks (social networks, biological networks etc) have different meta data attached to their nodes and edges. However, at a 
                                fundamental level, the algorithms and the analyses you would have to perform on them are the same, regardless of what the networks represent.                                 
                                That is not the case for networks with fundamental metadata. In this case you need to be aware of what the metadata represent, because they 
                                change the way you perform the analysis and you interpret the results.</div>
                            <div class="subsubtitle">3. Bayesian Network</div>
                            <div>In the classical example, you might have three variables: the probability of raining, the probability of having the sprinklers on, 
                                and the probability that the grass is wet. Clearly, rain and sprinklers both might cause the grass to be wet, so the two variables 
                                point to them. Rain also might influence the sprinklers, because the automatic system to save water will not turn them on when it’s 
                                raining, since it would be pointless. Obviously, the fact that the sprinklers are on will have no effect on whether it will rain or not.</div>
                            <div class="subsubtitle">4. Neural Networks</div>
                            <div>The way that they work, is that the weight on each node of the output layer is the answer the model is giving. See more page 65 in TAANS</div>
                    </div>
                </div>
            </div>
            <footer class="main-footer"> 
                <div class="container">
                    <nav class="footer-nav"> 
                        <ul>
                            <li> <a href="about.html"> About </a></li>
                            <li> <a href="learnmore.html"> Learn More </a></li>
                        </ul>
                    </nav>
                    <nav class="footer-nav"> 
                        <ul>
                            <li> 
                                <a href="https://www.linkedin.com/in/marie-haahr/" class="social-link" target="_blank">
                                    <img src="../images/linkedin2.png" height="30" width="30">
                                    Linkedin
                                </a>
                            </li>
                    </nav>
                </div>
            </footer>
        <script>
            // JavaScript to add the 'visible' class after the website has loaded
            document.addEventListener("DOMContentLoaded", function () {
                var pageWrapper = document.querySelector(".website-wrapper");
                pageWrapper.classList.add("visible");
            });
        </script>
    </body>
</html>